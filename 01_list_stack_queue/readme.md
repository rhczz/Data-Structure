# 表、栈和队列

## 1.1 抽象数据类型

程序设计的基本法则：例程不应超过一页。这可以通过把程序分割成一些模块来实现。每个模块是一个逻辑单位并执行某些特定的任务，它通过调用其他模块而使本身保持很小。

优点：
1. 调试小程序比调试大程序要容易的多。
2. 多个人同时对一个模块化程序编程要更容易。
3. 一个写得好的模块化程序把某些依赖关系局限在一个例程中，这样使修改更加容易。

抽象数据类型是一些操作的集合。

## 1.2 表（list）

如果表的大小N。我们称大小为0的表为空表（empty list）。

对于除空表外的任何表，我们说A<sub>i+1</sub>后继A<sub>i</sub>(或者继A<sub>i</sub>之后)并称A<sub>i-1</sub>(i<N)前驱A<sub>i</sub>(i>1).

### 1.2.1 表的简单数组实现

对表的所有实现都可以通过数组来实现。虽然数组是动态指定的，但是还是需要对表的大小的最大值进行预估。通常需要估计的稍微大一点，而这会浪费大量的空间。这是严重的局限，特别是在对表存在许多未知情况的表。

对于使用数组实现的表，如果进行要查询某个特定位置的元素则花费的是常数时间。但是如果要对表中的元素进行新增或者删除，则需要花费线性时间。比如要删除第一个元素，则需要后边的每个元素都往前移一个位置，如果要在第一个位置新增一个元素，则需要将后边的元素都往后移动一个位置，才能给这个元素腾出地方。

### 1.2.2 链表

为了避免插入和删除的线性开销，我们允许表可以不连续存储。

链表由一系列不必在内存中相连的结构组成。每个结构都含有表元素和指向该元素的后继元素的结构的指针，称为Next指针。最后一个单元的指针指向NULL。

Next指针存储的就是另一个数据的地址。如果需要查找链表中的某个元素，我们需要将指针传递到链表的第一个元素，然后通过Next指针该表。这种操作是线性时间的，查找表中的某个元素的操作，使用链表的效率是不如数组的。但是时间操作中查找链表中的第i个元素，通常是以i的顺序的方式操作的。例如FindKth(L, 2)、FindKth(L, 4)、FindKth(L, 6)就可以通过对表的一次扫描来实现。

链表删除可以通过修改一个指针来实现，比如要删除A<sub>3</sub>就可以通过将A<sub>2</sub>的Next指针指向A<sub>4</sub>。

插入元素需要使用一次malloc调用从系统中得到一个新的单元，并且执行两次指针调整。

### 1.2.3 程序设计细节

通过上述的描述确实可以实现对链表的简单操作，但是有几个地方可能依旧会出现问题：
1. 表头不能插入元素。
2. 如果从表的起始端删除元素，会造成表的表的起始端改变可能会造成表的丢失。
3. 虽然上述描述的删除元素的方法很简单，但是删除元素需要我们记住被删除元素的前一个表元。

稍微做一个简答的改动就可以解决上述的三个问题。在链表的开始可以留出一个标记节点，有时称之为表头或者哑节点。这是一种惯例。

为了避免删除操作相关的问题，需要编写一个FindPrevious，它返回我们删除表元的前驱节点的位置，如果要删除的第一个表元则返回表头的位置。